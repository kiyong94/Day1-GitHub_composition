
# **<Day2 : Linux명령어에 대한 보고서>**

## **1. 자주 사용하는 Linux 기본 명령어**

<br>

>### **(1) 도움말 명령어**

- `man` : 명령어에 대한 온라인 메뉴얼을 출력
- `whatis` : 명령어에 대한 간단한 설명 출력
- `whereis` : 특정 명령어의 실행파일 절대경로와 소스코드, 설정파일 및 메뉴얼 페이지를 출력
- `which` : 특정 명령어의 경로를 출력

---

>### **(2) 사용자 생성 및 계정관리 명령어**

- `useradd` : 기존 사용자 데이터 변경
- `usermod` : 새 사용자 추가
- `passwd` : 기존 사용자의 암호 생성 또는 업데이트
- `su` : 현재의 사용자 계정에서 로그아웃하지 않고 다른 사용자 계정으로 로그인하여 해당 사용자의 권한을 획득
- `sudo` : 현재 계정에서 root 권한을 이용하여 명령어를 실행할 때 사용
- `who` : 현재 시스템에 로그인되어 있는 사용자를 출력
- `whoami` : 실질적으로 사용중인 권한자를 출력

---

>### **(3) 디렉터리 및 파일 명령어**

- `pwd` : 현재 작업 중인 디렉터리의 위치를 나타냄
- `cd` : 디렉토리를 이동할 때 사용
- `mkdir` / rmdir : 디렉토리를 생성 및 삭제
- `ls` : 현재 위치한 디렉터리의 파일 목록들을 나타냄
- `mv` : 파일 또는 디렉터리를 이동 또는 이름 바꾸기
- `cp` : 파일 또는 디렉터리를 복사
- `rm` : 파일 또는 디렉토리를 삭제
- `ln` : 다른 파일에 대한 심볼릭 링크(바로 가기) 만들기
- `touch` : 파일크기가 0바이트인 빈 파일 생성
- `find` : 현재 디렉터리에서부터 하위 디렉터리까지 주어진 조건의 파일을 찾아 경로를 표시
- `cat` : 터미널에 파일 내용 표시
- `head` : 파일의 앞부분을 지정한 만큼 출력
- `tail` : 파일의 마지막 행을 기준으로 지정한 행까지 파일 내용 일부를 출력
- `less` : 텍스트 파일을 터미널에 한 번에 한 화면씩 나타냄
- `grep` : 출력 내에서 문자열 검색
- `sort` : 출력하는 동안 파일 내용을 정렬하는 Linux 명령
- `diff` : 두 파일을 행 단위로 비교하여 다른 부분을 출력
- `cmp` : 두 파일을 바이트(문자) 단위로 비교하여 출력
- `comm` : diff와 cmp의 기능을 결합하여 줄 단위로 비교하여 출력
- `tar` : Linux에서 파일을 추출하고 압축하는 명령
- `zip` : Linux의 zip 파일
- `unzip` : Linux에서 파일 압축 풀기

---

>### **(4) 파일 시스템 관련 명령어**

- `chown` : 파일 또는 디렉터리의 소유권을 부여하는 명령
- `chmod` : 파일 또는 디렉터리의 권한을 변경하는 명령
- `mount` : 파일 시스템 마운트(특정 디바이스를 특정 디렉터리처럼 사용하기 위해 장치와 디렉터리를 연결)
- `du` : Disk Usage의 약자로 디렉터리별로 디스크 사용량을 확인
- `df` : 시스템 전체에  마운트 된 디스크 사용량을 확인

---

>### **(5) 네트워크 관련 명령어**

- `traceroute` : 목적지 호스트까지의 경로를 표시하고 그 구간의 정보를 기록
- `ssh` : 네트워크상의 다른 컴퓨터에 로그인하거나 원격시스템에서 명령 실행, 파일 복사 등을 제공
- `ifconfig` : 네트워크 인터페이스 구성을 위한 설정 또는 확인, IP 주소 표시

---

>### **(6) 프로세스 관련 명령어**

- `ps` : 현재 실행 중인 프로세스 표시
- `kill` / `killall` : 프로세스 ID 또는 이름으로 활성 프로세스 종료
- `top` : 시스템 사용량과 함께 활성 프로세스를 실시간으로 봅니다.

---

>### **(7) 기타 명령어**

- `alias` : 정기적으로 사용하는 명령에 대한 사용자 지정 바로 가기 만들기
- `cal` : 시스템에 설정된 달력을 출력
- `clear` : 터미널 디스플레이 지우기
- `echo` : 명령 다음에 오는 모든 텍스트를 인쇄합니다.
- `history` : 작업했던 command 내용 확인

---

<br><br>

## **2. bashshell 스크립트**

<br>

>### **쉘 스크립트 기본 문법**

1. 쉘 스크립트는 파일로 작성 후, 파일을 실행 한다.
2. 파일의 가장 위 첫 라인은 `#!/bin/bash`로 시작한다.
3. 쉘 스크립트 파일은 코드를 작성한 후에는 실행 권한을 부여해야한다.
4. 일반적으로 '파일이름.sh' 와 같은 형태로 파일 이름을 작성한다.
5. 주석은 #내용 으로 처리한다.

---

>### **사전에 정의된 지역 변수**
  
```
$$ : 쉘의 프로세스 번호 (pid)
$0 : 쉘 스크립트 이름
$1~$9 : 명령줄 인수
$* : 모든 명령줄 인수 리스트
$# : 인수의 개수
$? : 최근 실행한 명령어의 종료 값 (0 성공, 1~125 에러, 126 파일이 실행가능하지 않음, 128~255 시그널 발생)
```

---

>### **(1) 변수** 

- 선언 : `변수명=데이터`

- 사용 : `$변수명(echo $변수명 $변수명 ...)`

- 주의사항 : `변수명=데이터` 사이에 띄어쓰기는 허용하지 않는다.

- 예제 : 변수(이름, 나이, 직업) 를 만들어보자

```
#!/bin/bash
myname='kky'
myage=29
myjob='programmer'
echo $myname$myage$myjob
```

---

>### (2) **리스트 변수(배열)**

- 선언 : `변수명=(데이터1데이터2데이터3...)`

- 사용 : `${변수명[인덱스번호]} `

- 주의사항 : 인덱스 번호는 0부터 시작이다.

- 예제 : 리스트 변수(이름, 나이, 직업) 를 만들고, 각 정보를 출력해보자

```
#!/bin/bash
me=("kky" "29" "programmer")
echo ${me[1]}                 // $me 배열의 두 번째 인덱스에 해당하는 값 출력
echo ${me[@]}                 // $me 배열의 모든 데이터 출력
echo ${me[*]}                 // $me 배열의 모든 데이터 출력
echo ${#me[@]}                // $me 배열의 배열 크기 출력
```

---

>### **(3) 연산자**

- `expr` : 숫자 계산

- `expr` 을 사용하는 경우 역 작은 따옴표 (`) 를 사용해야한다.

- 연산자 * 와 괄호 ( ) 앞에는 역 슬래시를 같이 사용해야 한다.(붙여 쓴다.)

- 연산자와 숫자, 변수, 기호 사이에는 space를 넣어야한다.

- 예제 : expr 명령으로 (10+20)/8 - 8 계산해보기

```
#!/bin/bash
a=10
b=20
c=8
num=`expr \( $a + $b \) / $c - $c`
```

---

>### **(4) 조건문**


- 기본 `if` 문법

```
if [ 조건 ] 
then

     명령문

fi
```

- 기본 `if/else` 구문
```
if [ 조건 ] 
then
     명령문      // 이 명령문에는 참일 때
else  
     명령문      // 이 명령문에는 거짓일 때
fi
```

- 기본 `case` 구문 
```
#!/bin/bash
case [문자열] in  
    경우1) 명령어1;;  
    경우2) 명령어1;;
    ...
    *) 명령어;;         // 모든 경우와 일치하지 않는 경우
esac  
```

- 수치 비교 : <, > 는 if 조건 시 [[]]를 넣는 경우 정상 작동하기는 하지만, 기본적으로 다음 문법을 사용한다.

```
A -eq B : A와 B가 같음(equal)  
A -ne B : A와 B가 같지 않음(not equal)  
A -lt B : A가 B보다 작음(less than)  
A -le B : A가 B보다 작거나 같음(less or equal)  
A -gt B : A가 B보다 큼(greater than)  
A -ge B : A가 B보다 크거나 같음(greater or equal)
```

- 파일 검사

```
-e 파일명 : 파일이 존재하면 참
-d 파일명 : 파일이 디렉토리면 참
-h 파일명 : 파일이 심볼릭 링크 파일이면 참
-f 파일명 : 파일이 일반파일이면 참
-r 파일명 : 파일이 읽기 가능하면 참
-s 파일명 : 파일크기가 0이 아니면 참
-u 파일명 : 파일이 set-user-id가 설정되면 참
-w 파일명 : 파일이 쓰기 가능이면 참
-x 파일명 : 파일이 실행 가능이면 참
```

- 논리 연산
```
조건1 -a 조건2 : AND
조건1 -o 조건2 : OR
조건1 && 조건2 : 양쪽 다 성립
조건1 || 조건2 : 한쪽 또는 양쪽 다 성립
!조건 : 조건이 성립하지 않음
true : 조건이 언제나 성립
false : 조건이 언제나 성립하지 않음
```

- 예제(1) : A와 B의 값이 다르면 'different values' 를 출력해보자

```
#!/bin/bash

A=1
B=2
if [ $A != $B ]
then
      echo "different values"
      exit
fi
```

- 예제(2) : 두 인자값을 받아서 두 인자값이 같으면 'same value', 다르면 'different value'가 출력되도록 해보자
```
#!/bin/bash

if [ $1 -eq $2 ]
then 
    echo "same values"
else
    echo "different values"
fi
```

---

>### **(5) 반복문**

- 반복문 문법 - 기본 `for` 구문

```
for 변수 in 변수값1 변수값2 ....
do 
    명령문
done
```

- 반복문 문법 - 기본 `while` 구문 
```
while [ 조건문 ]  
do 
     명령문 
done
``` 

- 예제 : 현재 디렉토리에 있는 파일과 디렉토리를 출력해보자

```
// (1) for문 사용

#!/bin/bash 

for database in $(ls) 
do  
     echo $database 
done


// (2) while문 사용

#!/bin/bash

lists=$(ls)
num=${#lists[@]}
index=0
while [ $num -ge 0 ]
do
     echo ${lists[$index]}
     index=`expr $index + 1`
     num=`expr $num - 1`
done
```

---

>### **(6) 쉘스크립트 프로그램 작성 실습**
<br>

```
// 간단한 게산기 프로그램 작성

#!/bin/bash
echo -n "첫번째 숫자를 입력해주세요 >> "          // echo -n : 프롬포트 출력
read Num1                                       // read : 사용자가 입력하는 내용을 읽어들이는 명령어
echo -n "연산기호를 입력해주세요 >>"
read Op
echo -n "두번째 숫자를 입력해주세요 >>"
read Num2
case $Op in
    '+')echo "$Num1 + $Num2 = `expr $Num1 + $Num2`";;
    '-')echo "$Num1 - $Num2 = `expr $Num1 - $Num2`";;
    '*')echo "$Num1 * $Num2 = `expr $Num1 \* $Num2`";;
    '/')echo "$Num1 / $Num2 = `expr $Num1 / $Num2`";;
    *)echo "Unknown Operator"; exit 1;;
esac
```

---

<br><br>

## **3. VIM**

<br>

>### **(1) VIM이란?**

- vim이란?
```
Linux의 대표적인 텍스트 편집기 vi와 호환되는 텍스트 편집기
```

- vim의 4가지 모드

1. 일반(Normal)모드 or 명령(Command)모드
```
- 사용자가 키보드를 통해서 타이핑 하는 모든 내용을 하나의 명령으로서 받아들이는 모드
- 기본으로 설정되어 있는 모드
```
2. 명령줄 모드(Command Line Mode)
```
- 사용자가 입력한 문장이 특정 명령어가 되는 모드
```
3. 편집/입력 모드(Insert Mode)
```
- 입력하는 모든 내용들이 문서의 내용이 되는 모드
- 단순히 타이핑 할 수 있는 모드에 해당
```
4. 비쥬얼/선택 모드(Visual)
```
- 문서를 구성하는 특정 부분의 내용을 선택할 때 사용하는 모드
```

- vim을 배워야하는 이유

```
우리가 사용하는 수많은 소프트웨어, 프로그램 시스템들이 리눅스 서버에서 서비스가 진행되고 있는 경우가 상당히 많기 때문에 개발자로서 폭넓게 일하기 위해서는 리눅스 서버를 활용할 수 있어야 한다. 바로 서버상에서 특정한 소스파일이나 문서파일을 편집할 때 대표적으로 사용하는 에디터가 바로 vim이다.
```

---

>### **(2) vim 명령어**

- 명령(Command)모드 -> 편집(Insert)모드로 진입하는 명령

```
i : 현재 커서의 앞에서 편집시작  
a : 현재 커서의 다음부터 편집시작  
A : 현재 라인의 맨 끝으로 커서를 이동하고 편집시작  
o : 현재 커서 아래에 새로운 줄을 추가하고 편집시작  
O : 현재 커서 위에 새로운 줄을 추가하고 편집시작  
s : 현재 위치의 문자를 지우고 입력모드로 진입  
S : 현재 위치의 라인을 모두 지우고 입력모드로 진입  
```

- 명령(Command)모드의 복사/지우기/붙여넣기 명령
```
x : 한 글자 지우기
dw : 현재 커서의 위치에 해당하는 단어 지우기
dd : 현재 커서가 위치한 라인을 지우기
(숫자)dd : 현재 커서가 위치한 라인부터 숫자만큼의 라인내용 삭제
D : 현재 커서의 위치부터 라인 끝까지 삭제
J : 커서 아래라인을 커서 라인에 공백하나를 추가하고 붙임
y : 한 라인의 내용을 모두 복사
p : 붙여넣기
```

- 명령(Command)모드의 Undo/Redo 명령
```
u : 마지막 명령을 취소
U : 해당 라인 전체에 대한 수정사항을 모두 취소
ctrl + r : u를 통해서 취소했던 명령을 다시 수행
. : 이전에 수행했던 명령을 다시 반복
```

- 명령(Command)모드의 내용변경 명령
```
r : 글자 하나를 변경할 때 사용
cw : 단어의 일부나 전체를 변경할 때 사용(커서가 위치한 단어 삭제 후 입력모드 진입)
c$ : 해당 줄 전체를 변경할 때 사용(커서가 위치한 라인 삭제 후 입력모드 진입)
```

- 명령(Command)모드의 커서이동 명령
```
h / (숫자)h : 왼쪽으로 이동 / (숫자)만큼 왼쪽으로 이동
j / (숫자)j : 아래쪽으로 이동 / (숫자)만큼 아래으로 이동
k / (숫자)k : 위쪽으로 이동 / (숫자)만큼 위쪽으로 이동
l / (숫자)l : 오른쪽으로 이동 / (숫자)만큼 오른쪽으로 이동
- : 라인의 시작으로 이동
e,E : 다음 단어의 끝으로, 문자단위 이동
w,W / b,B : 다음 단어의 처음으로, 문자단위 이동(시작->끝 / 끝->시작)
$ : 줄의 마지막으로 이동
0 : 줄의 처음으로 이동
^ : 줄의 처음으로 이동(공백을 제외한 문자가 처음 시작되는 지점)
Shift + g : 문서의 마지막으로 이동
gg : 문서의 처음으로 이동
(숫자)Shift + g : (숫자)번째 줄로 이동
),( : 다음, 이전 문장의 처음으로
},{ : 다음, 이전 문단의 처음으로
]],[[ : 다음, 이전 구절의 처음으로
```

- 명령(Command)모드의 글자(단어)찾기 / 변경 명령
```
/글자(단어) : 커서 기준 아래쪽으로 글자(단어)찾기
?글자(단어) : 커서 기준 위쪽으로 글자(단어)찾기
n : 이전에 검색한 단어를 검색했던 방향으로 다시 검색
N : 이전에 검색한 단어를 검색했던 방향의 반대방향으로 다시 검색
:s/찾는단어/새단어 : 현재 라인에서 찾는 단어를 새 단어로 한 번만 찾아서 바꾸기
:%s/찾는단어/새단어/g : 현재 파일에서 찾는 단어를 새 단어로 모두 바꾸기
:%s/찾는단어/새단어/gc : 현재 파일에서 찾는 단어를 새 단어로 모두 바꾸되 물어보면서 바꾸기
```

- 명령(Command)모드의 화면스크롤 명령
```
ctrl + F : 한 화면을 앞으로 스크롤
ctrl + B : 한 화면을 뒤로 스크롤
ctrl + E : 한줄 앞으로 스크롤
ctrl + Y : 한줄 뒤로 스크롤
Shift + h : 화면의 맨 윗줄로
Shift + l : 화면의 맨 아랫줄로
```

- 명령(Command)모드의 화면 분할 명령
```
:vs 파일명 : 수직으로 창을 나눈 후, 해당 파일 불러오기
:sp 파일명 : 수평으로 창을 나눈 후, 해당 파일 불러오기
ctrl + ww : 분할된 창들간의 이동
```

- 현재 파일을 저장하고 vim종료 명령
```
ZZ : 현재 파일을 저장하고 vim 종료 (Command 모드에서)
:wq : 현재 파일을 저장하고 vim 종료 (Command Line모드에서)
:w : 현재 파일을 저장 (Command Line모드에서)
:q : vim종료 (Command Line모드에서)